package songvote

import (
	"bytes"
	"encoding/json"
	"fmt"
	"strings"
)

// Song contains information about a single song.
type Song struct {
	ID      int    `json:"id"`       // generated by store
	Name    string `json:"name"`     // song nam
	Artist  string `json:"artist"`   // song artist
	LinkURL string `json:"link_url"` // link to YouTube, Spotify, etc.
	Votes   int    `json:"votes"`    // number of votes received
	Vetoed  bool   `json:"vetoed"`   // this song has been vetoed
}

// (Song).Equals returns whether names and artists of two Song objects are the same.
func (s Song) Equals(other Song) bool {
	return (s.Name == other.Name) && (s.Artist == other.Artist)
}

// (Song).Marshal returns JSON-encoded string of the Song object.
func (s Song) Marshal() (string, error) {
	output := bytes.NewBuffer([]byte{})
	err := json.NewEncoder(output).Encode(s)
	if err != nil {
		return "", fmt.Errorf("problem encoding song to JSON: %w", err)
	}
	return output.String(), nil
}

// UnmarshalSong returns JSON-encoded string of the Song object.
func UnmarshalSong(jsonString string, song *Song) error {
	err := json.NewDecoder(strings.NewReader(jsonString)).Decode(song)
	if err != nil {
		return fmt.Errorf("problem decoding song from JSON: %w", err)
	}
	return nil
}
